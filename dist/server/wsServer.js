import{applyWSSHandler as q}from"@trpc/server/adapters/ws";import{WebSocketServer as z}from"ws";import{initTRPC as T}from"@trpc/server";import{getServerSession as A}from"next-auth";import _ from"superjson";import{ZodError as I}from"zod";import{PrismaClient as U}from"@prisma/client";import{createEnv as x}from"@t3-oss/env-nextjs";import{z as R}from"zod";var w=x({server:{DATABASE_URL:R.string().url(),NODE_ENV:R.enum(["development","test","production"]).default("development")},client:{},runtimeEnv:{DATABASE_URL:process.env.DATABASE_URL,NODE_ENV:"production"},skipValidation:!!process.env.SKIP_ENV_VALIDATION,emptyStringAsUndefined:!0});var D=()=>new U({log:w.NODE_ENV==="development"?["query","error","warn"]:["error"]}),b=globalThis,y=b.prisma??D();w.NODE_ENV!=="production"&&(b.prisma=y);var S=async t=>({db:y,...t}),d=T.context().create({transformer:_,errorFormatter({shape:t,error:n}){return{...t,data:{...t.data,zodError:n.cause instanceof I?n.cause.flatten():null}}}}),P=d.middleware,V=P(async t=>{let n=await A();if(!n?.user)throw new Error("Not authorized");return t.next({ctx:{session:n}})}),F=d.createCallerFactory,m=d.router,c=d.procedure,te=d.procedure.use(V);import{EventEmitter as W}from"events";import{observable as B}from"@trpc/server/observable";import{z as s}from"zod";import{z as a}from"zod";var C=a.object({name:a.string().nullable(),email:a.string().email().nullable()}),v=a.object({title:a.string(),content:a.string(),link:a.string(),isFavourite:a.boolean().optional(),ownerId:a.string().nullable().optional()});import{TRPCError as l}from"@trpc/server";var E=new W,k=m({onContentUpdate:c.input(s.string()).subscription(({input:t})=>B(n=>{let r=e=>{e.room===t&&n.next(e.content)};return E.on("contentUpdate",r),()=>{E.off("contentUpdate",r)}})),updateContent:c.input(s.object({room:s.string(),content:s.string()})).mutation(({input:t})=>{E.emit("contentUpdate",t)})}),N=m({createUserFileMutation:c.input(s.object({userData:C,fileData:v})).mutation(async({ctx:t,input:n})=>{let{userData:r,fileData:e}=n;try{return r?.email?await t.db.$transaction(async o=>{if(r?.email){let i=await o.user.upsert({where:{email:r.email},update:{name:r.name??null},create:{email:r.email,name:r.name??null}});return await o.file.upsert({where:{link:e.link},update:{title:e.title??null,content:e.content,owner:{connect:{id:i.id}}},create:{title:e.title,content:e.content,link:e.link,owner:{connect:{id:i.id}}},include:{owner:!0}})}}):await t.db.file.upsert({where:{link:e.link},update:{title:e.title??"Untitled",content:e.content},create:{title:e.title,content:e.content,link:e.link},include:{owner:!0}})}catch(o){if(o instanceof Error){if(o.message.includes("Unique constraint"))throw new l({code:"CONFLICT",message:"A file with this link already exists"});if(o.message.includes("Foreign key constraint"))throw new l({code:"BAD_REQUEST",message:"Invalid user reference"})}throw console.error("Error saving file:",o),new l({code:"INTERNAL_SERVER_ERROR",message:"Failed to save file"})}}),getFileData:c.input(s.string()).query(async({ctx:t,input:n})=>{let r=n,e=await t.db.file.findUnique({where:{link:r},include:{owner:!0}});if(!e)throw new l({code:"NOT_FOUND",message:"File not found"});return{content:e.content,title:e.title,isFavourite:e.isFavourite,userEmail:e?.owner?.email,isViewOnly:e?.isViewOnly}}),getAllFiles:c.input(s.string()).query(async({ctx:t,input:n})=>{let r=n,e=await t.db.user.findUnique({where:{email:r},include:{files:{orderBy:{updatedAt:"desc"},select:{title:!0,link:!0,isFavourite:!0}}}});if(!e)throw new l({code:"NOT_FOUND",message:"User not found"});return e.files.map(i=>({title:i.title,link:i.link,isFavourite:i.isFavourite}))}),toggleFavourite:c.input(s.string()).mutation(async({ctx:t,input:n})=>{let r=await t.db.file.findUnique({where:{link:n}});if(!r)throw new l({code:"NOT_FOUND",message:"File not found"});return await t.db.file.update({where:{link:n},data:{isFavourite:!r.isFavourite}})}),toggleViewOnly:c.input(s.object({link:s.string(),isViewOnly:s.boolean(),userEmail:s.string()})).mutation(async({ctx:t,input:n})=>{let r=await t.db.file.findUnique({where:{link:n.link},include:{owner:!0}});if(!r)throw new l({code:"NOT_FOUND",message:"File not found"});if(r.owner?.email!==n.userEmail)throw new l({code:"FORBIDDEN",message:"Only the owner can modify view-only status"});return await t.db.file.update({where:{link:n.link},data:{isViewOnly:n.isViewOnly}})})});var h=m({editor:k,userFile:N}),fe=F(h);var u=new Map,j=async({})=>{let t=new Headers;return S({headers:t})},f=new z({port:3001,host:"localhost"}),L=q({wss:f,router:h,createContext:j}),O=t=>{let n=u.get(t);if(!n)return;let r=n.size;console.log(`Broadcasting active users: ${r}`);let e=JSON.stringify({type:"ACTIVE_USERS",payload:r,room:t});f.clients.forEach(o=>{let i=o;i.roomId===t&&i.send(e)})};f.on("connection",t=>{let n=t,r,e;t.on("message",o=>{try{let i=typeof o=="string"?o:Buffer.isBuffer(o)?o.toString():"",g=JSON.parse(i);if(g.type==="INIT"){r=g.id,e=g.room,n.roomId=e,u.has(e)||u.set(e,new Set);let p=u.get(e);p&&!p.has(r)&&(p.add(r),console.log(`+ + Room (${e}) (${p.size})`),O(e))}}catch(i){console.log("Error parsing message:",i)}}),t.on("close",()=>{if(r&&e){let o=u.get(e);o&&(o.delete(r),O(e),o.size===0&&u.delete(e))}})});process.on("SIGTERM",()=>{L.broadcastReconnectNotification(),u.clear(),f.close()});export{L as handler,f as wss};
