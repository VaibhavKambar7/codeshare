import{applyWSSHandler as G}from"@trpc/server/adapters/ws";import{WebSocketServer as K,WebSocket as Q}from"ws";import{initTRPC as B}from"@trpc/server";import{getServerSession as M}from"next-auth";import z from"superjson";import{ZodError as L}from"zod";import{PrismaClient as V}from"@prisma/client";import{createEnv as P}from"@t3-oss/env-nextjs";import{z as T}from"zod";var v=P({server:{DATABASE_URL:T.string().url(),NODE_ENV:T.enum(["development","test","production"]).default("development")},client:{},runtimeEnv:{DATABASE_URL:process.env.DATABASE_URL,NODE_ENV:"production"},skipValidation:!!process.env.SKIP_ENV_VALIDATION,emptyStringAsUndefined:!0});var q=()=>new V({log:v.NODE_ENV==="development"?["query","error","warn"]:["error"]}),N=globalThis,E=N.prisma??q();v.NODE_ENV!=="production"&&(N.prisma=E);var R=async e=>({db:E,...e}),f=B.context().create({transformer:z,errorFormatter({shape:e,error:t}){return{...e,data:{...e.data,zodError:t.cause instanceof L?t.cause.flatten():null}}}}),$=f.middleware,j=$(async e=>{let t=await M();if(!t?.user)throw new Error("Not authorized");return e.next({ctx:{session:t}})}),C=f.createCallerFactory,g=f.router,l=f.procedure,ue=f.procedure.use(j);import{EventEmitter as H}from"events";import{observable as J}from"@trpc/server/observable";import{z as s}from"zod";import{z as a}from"zod";var F=a.object({name:a.string().nullable(),email:a.string().email().nullable()}),x=a.object({title:a.string(),content:a.string(),link:a.string(),language:a.string().optional(),isFavourite:a.boolean().optional(),ownerId:a.string().nullable().optional()});import{TRPCError as u}from"@trpc/server";var b=new H,O=g({onContentUpdate:l.input(s.string()).subscription(({input:e})=>J(t=>{let o=r=>{r.room===e&&t.next(r.content)};return b.on("contentUpdate",o),()=>{b.off("contentUpdate",o)}})),updateContent:l.input(s.object({room:s.string(),content:s.string()})).mutation(({input:e})=>{b.emit("contentUpdate",e)})}),A=g({createUserFileMutation:l.input(s.object({userData:F,fileData:x})).mutation(async({ctx:e,input:t})=>{let{userData:o,fileData:r}=t;try{return o?.email?await e.db.$transaction(async n=>{if(o?.email){let i=await n.user.upsert({where:{email:o.email},update:{name:o.name??null},create:{email:o.email,name:o.name??null}});return await n.file.upsert({where:{link:r.link},update:{title:r.title??null,content:r.content,language:r.language,owner:{connect:{id:i.id}}},create:{title:r.title,content:r.content,link:r.link,language:r.language,owner:{connect:{id:i.id}}},include:{owner:!0}})}}):await e.db.file.upsert({where:{link:r.link},update:{title:r.title??"Untitled",content:r.content,language:r.language},create:{title:r.title,content:r.content,link:r.link,language:r.language},include:{owner:!0}})}catch(n){if(n instanceof Error){if(n.message.includes("Unique constraint"))throw new u({code:"CONFLICT",message:"A file with this link already exists"});if(n.message.includes("Foreign key constraint"))throw new u({code:"BAD_REQUEST",message:"Invalid user reference"})}throw console.error("Error saving file:",n),new u({code:"INTERNAL_SERVER_ERROR",message:"Failed to save file"})}}),getFileData:l.input(s.string()).query(async({ctx:e,input:t})=>{let o=t,r=await e.db.file.findUnique({where:{link:o},include:{owner:!0}});if(!r)throw new u({code:"NOT_FOUND",message:"File not found"});return{content:r.content,title:r.title,isFavourite:r.isFavourite,language:r.language??"",userEmail:r?.owner?.email,isViewOnly:r?.isViewOnly}}),getAllFiles:l.input(s.string()).query(async({ctx:e,input:t})=>{let o=t,r=await e.db.user.findUnique({where:{email:o},include:{files:{orderBy:{updatedAt:"desc"},select:{title:!0,link:!0,isFavourite:!0}}}});if(!r)throw new u({code:"NOT_FOUND",message:"User not found"});return r.files.map(i=>({title:i.title,link:i.link,isFavourite:i.isFavourite}))}),toggleFavourite:l.input(s.string()).mutation(async({ctx:e,input:t})=>{let o=await e.db.file.findUnique({where:{link:t}});if(!o)throw new u({code:"NOT_FOUND",message:"File not found"});return await e.db.file.update({where:{link:t},data:{isFavourite:!o.isFavourite}})}),toggleViewOnly:l.input(s.object({link:s.string(),isViewOnly:s.boolean(),userEmail:s.string()})).mutation(async({ctx:e,input:t})=>{let o=await e.db.file.findUnique({where:{link:t.link},include:{owner:!0}});if(!o)throw new u({code:"NOT_FOUND",message:"File not found"});if(o.owner?.email!==t.userEmail)throw new u({code:"FORBIDDEN",message:"Only the owner can modify view-only status"});return await e.db.file.update({where:{link:t.link},data:{isViewOnly:t.isViewOnly}})})});var y=g({editor:O,userFile:A}),ke=C(y);var U=5,X=3e3,d=new Map,c=null,Z=async({})=>{let e=new Headers;return R({headers:e})};function _(e=3001,t="localhost"){try{c=new K({port:e,host:t,clientTracking:!0});let o=G({wss:c,router:y,createContext:Z});return c.on("error",r=>{console.error("WebSocket server error:",r),h()}),c.on("close",()=>{console.log("WebSocket server closed. Attempting to restart..."),h()}),{server:c,handler:o}}catch(o){throw console.error("Failed to setup WebSocket server:",o),o}}function h(e=0){e>=U&&(console.error("Maximum reconnection attempts reached. Manual intervention required."),process.exit(1)),setTimeout(()=>{try{c&&c.close();let{server:t}=_();c=t,console.log("WebSocket server successfully restarted")}catch(t){console.error(`Failed to restart WebSocket server (attempt ${e+1}/${U}):`,t),h(e+1)}},X)}var D=e=>{if(!c)return;let t=d.get(e);if(!t)return;let o=t.size;console.log(`Broadcasting active users: ${o}`);let r=JSON.stringify({type:"ACTIVE_USERS",payload:o,room:e});c.clients.forEach(n=>{let i=n;if(i.roomId===e&&i.readyState===Q.OPEN)try{i.send(r)}catch(p){console.error(`Failed to send message to client in room ${e}:`,p)}})};function W(e){e.isAlive=!0,e.pingTimeout&&clearTimeout(e.pingTimeout),e.pingTimeout=setTimeout(()=>{e.terminate()},31e3)}var{server:m,handler:I}=_();if(m){let e=setInterval(()=>{m.clients.forEach(t=>{let o=t;if(o.isAlive===!1)return t.terminate();o.isAlive=!1,t.ping()})},3e4);m.on("close",()=>{clearInterval(e)}),m.on("connection",t=>{let o=t;o.isAlive=!0;let r,n;W(o),o.on("pong",()=>W(o)),t.on("message",i=>{try{let p=typeof i=="string"?i:Buffer.isBuffer(i)?i.toString():"",S=JSON.parse(p);if(S.type==="INIT"){r=S.id,n=S.room,o.roomId=n,d.has(n)||d.set(n,new Set);let w=d.get(n);w&&!w.has(r)&&(w.add(r),console.log(`+ + Room (${n}) (${w.size})`),D(n))}}catch(p){console.error("Error processing message:",p)}}),t.on("close",()=>{if(o.pingTimeout&&clearTimeout(o.pingTimeout),r&&n){let i=d.get(n);i&&(i.delete(r),D(n),i.size===0&&d.delete(n))}}),t.on("error",i=>{console.error("WebSocket connection error:",i),t.terminate()})})}var k=()=>{console.log("Shutting down WebSocket server..."),I&&I.broadcastReconnectNotification(),d.clear(),m&&m.close(()=>{console.log("WebSocket server closed successfully"),process.exit(0)})};process.on("SIGTERM",k);process.on("SIGINT",k);process.on("uncaughtException",e=>{console.error("Uncaught exception:",e),k()});export{I as handler,m as wss};
